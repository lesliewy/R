# TODO: Add comment
# 
# Author: leslie
###############################################################################


# 获取预测模型


# 1. 多元线性回归.
# 首先要填补NA值，  R的线性回归中不允许有NA值.
data(algae)
algae <- algae[-manyNAs(algae), ]
clean.algae <- knnImputation(algae, k = 10)   # 使用案例间的距离的方法来填补NA值.

lm.a1 <- lm(a1 ~ ., data = clean.algae[, 1:12]);   # lm() 建立一个线性回归模型, 第一个参数给出模型的函数形式, "."代表数据框中所有
    # 除a1外的变量，即用其他所有变量来预测a1. a1 ~ mxPH + NH4 表示用mxPH、NH4来预测a1.  结果返回一个包含线性模型信息的对象. data 表示
    # 建模所需的数据集，这里是11个解释变量加上a1.
#summary(lm.a1)   # R处理名义变量: 对有k个水平的因子变量，生成k-1个辅助变量(这里是seasonspring, seasonsummer, seasonwinter).这些辅助
    # 变量的值是0或1. 为1表示该因子出现，其他因子不出现为0. 如果所有辅助变量取值都是0，表明因子取值为剩下的第k个值.
    # summary()中首先是数据拟合的残差(Residuals), 残差应该是均值为0，且为正态分布。残差越小越好.
    # 对于每个多元线性回归方程的系数(变量), R显示它的估计值和标准误差. 为了检验系数的重要性，可以进行这些系数为0的检验，通常使用t检验来验证这些
    # 假设。R计算t值: 估计系数值／标准误差.
    # Pr(>|t|) 表示系数为0这一假设被拒绝的概率. 后面带"*" 标志的，至少有90%以上的置信度来拒绝系数为0这一假设, 例如: Pr(>|t|)为0.02166，表示
    # 有97.834的概率该项参数的系数不是0；
    # 多元R2信息: 表明模型与数据的吻合度. 越接近于1说明模型拟合的越好；越小，则拟合的越差.
    # 调整R2信息：比R2更严格，考虑回归模型中参数的数量.(这里是32%，不是很好）.
    # F统计值和p值: 检验任何解释变量和目标变量没有依赖关系这一原假设。 R提供一个拒绝原假设的置信度水平，即p值. 如果p值为0.0001表示有99.99%
    # 的置信度确定原假设是错误的.通常，如果一个模型不能通过这个检验(即得到的p值太大，例如大于0.1),则单个系数的p检验没有意义.
# plot(lm.a1)    # 线性模型图.

# 该模型解释的方差比例不是很好(32%左右), 还可以拒绝目标变量不依赖于解释变量的假设(F检验的p值很小). 可能质疑某些变量是否进入模型中,可以精简模型
# 例如向后消元法.
# anova(lm.a1) : 精简线性模型. 发现season项的Pr(>F)的值最大，说明这个参数对减少模型拟合误差的贡献最小. 可以从模型中剔除.
# lm2.a1 <- update(lm.a1, . ~ . -season);    # update()对已有模型微调: 移除变量season    
# summary(lm2.a1)      # 新模型的拟合指标R2提高到32.8%， 但仍不理想.

#anova(lm.a1, lm2.a1);  # 比较两个模型.  通过F检验对两个模型进行方差分析，据此评估两个模型是否有显著不同. 尽管误差减少了(-448),但是两者的
   # 差距并不显著(显著性值为0.6971, 说明两个模型不同的概率有30%).
# 可以不断重复应用anova来精简模型，进行向后消元的过程.
# final.lm <- step(lm.a1)    # 不断重复上面的anova() 精简模型的过程，直至没有可剔除的候选系数. step()默认情况下使用向后消元，参数direction
      #可以来改变.   
#summary(final.lm)     # R2仍然不是很高，说明对海藻案例应用假定的线性模型是不合适的.

# 2. 回归树.
# 回归树模型可以处理NA值, 所以只需去掉用过多NA值的那些行.
#library(rpart)   # 回归树模型在rpart包中.
#data(algae)
#algae <- algae[-manyNAs(algae), ]    # 只需去掉有过多NA的那些行.
#rt.a1 <- rpart(a1 ~ .,data=algae[,1:12])
#rt.a1       # 树从标为1的根节点开始读：一个有198个水样，海藻a1出现的平均频率为16.99,相对平均值的偏差(不同值与平均值差的平方和)为90401.29.
   # rpart 满足下列过程时将结束: 1) 偏差的减少小于某一个给定界限值时. 2) 当节点中的样本数量小于某个给定界限时.  3) 当树的深度大于一个给定的
   # 界限值.  分别由3个参数来控制: cp, minsplit, maxdepth, 默认值分别为 0.01, 20, 30.  可以修改这些值来避免出现过度拟合的问题.

#prettyTree(rt.a1)   # 使用plot() 和text()来美化树图.
#summary(rt.a1)      # 也可以使用summary()

#printcp(rt.a1)    # 复杂度损失修建方法，这种方法试图估计cp值以确保达到预测的准确性和树的大小之间的最佳折中. printcp() 可以展示这些信息.
    # rpart()函数建立的回归树是最后一个(树9), 这个树的cp值为0.01, 该树包括9个测试和一个相对误差值(rel error, 与根节点相比)0.354, 
    # 交叉验证的估计误差(xerror)为0.70241(每次可能不一样，因为是随机取样). 最后一列是标准误差(xstd). 可以根据 1-SE规则来选择最好的回归
    # 树: xerror + xstd 最小的那个回归树.
#rt2.a1 <- prune(rt.a1, cp = 0.08)    # 选择不同的cp值来修剪树.

#first.tree <- rpart(a1 ~ .,data=algae[,1:12])
#snip.rpart(first.tree,c(4,7))    # 交互的对树进行修剪.

#prettyTree(first.tree)
#snip.rpart(first.tree)           #  图形窗口下修剪。 首先画出树， 然后调用没有第二个参数的snip.rpart()函数.

